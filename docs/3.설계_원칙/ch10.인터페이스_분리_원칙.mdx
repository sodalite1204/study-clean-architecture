---
sidebar_position: 4
---

# 10장 인턴페이스 분리 원칙

💡 **인턴페이스 분리 원칙 (ISP: Interface Segregation Principle)** 스프트웨어 설계자는 _사용하지 않는 것에 의존하지 않아야 한다._

---

## 10-1. Intro

```text
[ User1 ] [ User2 ] [ User3 ]
    |         |         |
    ⎣______[ OPS ]______⎦
        +op1 +op2 +op3
```

- OPS -> 정적 타입 언어로 작성된 클래스
- User1에서는 op2 op3를 전혀 사용하지 않음
  - User1의 소스 코드는 이 두 메서드에 의존
- 이런, 의존성으로 인해 OPS 클래스에서 op2의 소스 코드가 변경
  - User1과 관련된 코드는 전혀 변경 안되도
  - User1도 다시 컴파일한 후 새로 배포
- 해결 방법
  - 오퍼레이션을 인터페이스 단위로 분리해여 해결
  - 분리하여 해결하면, 정적 타입언어라도 의존도가 달라져 전혀 관계없는 변경에 다시 컴파일하고 배포하지 않아도 된다.

## 10-2. ISP와 언어

- 정적 타입 언어

  - 사옹자가 import, use 또는 include와 같은 타입 선언문을 사용하도록 강제
  - 소스 코드에 포함된 선언문으로 인해 소스 코드 의존성이 발생
  - 제컴파일 또는 재배포가 강제되는 상황이 초래

- 동적 언어 (루비, 파이썬 등)

  - 소스 코드에 이러한 선언문이 존재하지 않음
  - 그러나 런타임에 추론이 발생
  - 소스 코드 의존성이 아예 없으면, 결국 재컴파일가 재배포가 필요없다.

- 동적 타입 언어를 사용하면 정적 타입 언어를 사용할 때보다 유연하며 결합도가 낮은 시스템을 만들 수 있는 이유
- 그래서, ISP를 아키텍처가 아니라 언어와 관련된 문제라고 결론내릴 여지가 있다.

## 10-3 ISP와 아키텍처

- ISP를 사용하는 근본적인 동기
  - 잠재되어 있는 더 깊은 우려사항을 볼 수 있다.
- 필요 이상으로 많은 걸 포함하는 모듈에 의존하는 것은 해로운 일
- 소스 코드 의존성
  - 불필요한 재컴파일과 재배포를 강제하기 때문
- 고수준인 아키텍처 수준에서도 많이 발생

## 10-4 결론

- 불필요한 짐을 실은 무언가에 의존하면 예상치도 못한 문제에 빠진다.
