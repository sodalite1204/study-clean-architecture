---
sidebar_position: 1
---

# 7장 단일 책임 원칙

💡 **단일 책임 원칙 (SRP: Single Responsibility Principle)** 콘웨이 법칙에 따름 정리: 소프트웨어 시스템이 가질 수 있는 최적의 구조는 시스
템을 만드는 조직의 사회적 구조에 커다란 영향을 받는다.
따라서 *각 소프트웨어 모듈은 변경의 이유가 단 하나*여만 한다.

---

## 7-1. Intro

- SOLID 정책중에서 의미 전달이 잘 되지 못한 원칙

  - 부적절한 이름 때문
  - 모든 모듈이 단 하나의 일만 해야 한다는 의미로 받아드리기 때문

- 하나의 일만 해야 한다는 원칙의 의미

  - 함수는 반드시 하나의 일만 해야 한다.
  - 커다란 함수를 작은 함수들로 리팩터링하는 더 저수준에서 사용된다.
  - SRP, 즉 SOLID 원칙이 아니다.

- **단일 모듈은 변경의 이유가 오직 하나뿐이어야 한다.**

  - 소프트웨어 시스템은 사용자가 이해관계자 들을 만족시키기 위해 변경된다.
  - 사용자와 이해관계자가 변경의 이유
  - 즉, 하나의 모듈은 하나의, 오직 하나의 사용자 또는 이해관계자에 대해서만 책임져야 한다.
  - 그러나, 사용자와 이해관계자는 시스템이 동일한 방식으로 변경되기를 원하는
    사용자나 이해관계자가 여러명일 수도 있다.
    - 여기서에서는 이런 의미 보다는 집단, 즉 해당 변경을 요청하는 한 명 이상의 사람들.
    - 이러한 집단 -> 액터(actor)
  - _즉, 하나의 모듈은 하나의, 오직 하나의 액터에 대해서만 책임져야 한다._

- 모듈

  - 소스 파일
  - 소스 파일을 저장하지 않는 경우는 함수와 데이터 구조로 구성된 응집된(SRP를 암시) 집합

- 단일 액터를 책임지는 코드를 함께 묶어주는 힘 -> 응집성(cohesion)
- 원칙을 이해하기 위해서 SRP를 위반하는 징후들을 살펴봐야 한다.

## 7.2. [예시]급여 애플리케이션

Emloyee클래스 -> 세 가지 메서드가 서로 다른 세 명의 액터를 책임

1. calculatePay()

- 기능 정의: 회계팀
- 용도: CFO 보고

2. reportHours()

- 기능 정의: 인사팀
- 용도: COO 보고

3. save()

- 기능 정의: 데이터베이스 관리자팀
- 용도: CTO 보고

### 7-2-1. 징후1. 우발적 중복

- CFO 팀에서 결정한 조치가 COO팀이 읜존하는 무언가에 영향을 줄 수 있음
  - calculatePay(), reportHours() 가 초가 근무를 제외한 업무 시간을 계산하는 알고리즘을 공유
  - 중복을 피하기 위해 regularHours() 메서도에 넣음
    - calculatePay() -> regularHours()를 호출
    - reportHours() -> regularHours()를 호출
  - CFO 팀에서 초과 근무를 제외한 업무 시간 계산 방식을 수정 요청
  - COO 팀에서 목적이 다르기 때문에 변경 원치 않음
  - 개발자는 연관되어있다는 사실을 모르고 CFO 팀의 요청 사항을 적용
- 정리
  - 서로 다른 액터가 의존한느 코드를 너무 가까이 배치했기 때문
  - SRP는 서로 다른 액터가 의존하는 코드를 서로 분리

### 7-2-2. 징후2. 병합

- 데이터베이스 관리자가 속한 CTO팀에서의 데이터베이스 Emloyee테이블 스키마 수정
- COO 팀에서 reportHours() 보고서 포맷변경을 결정
- 두 명의 개발자가 변경 사항을 적용

  - 서로 충돌 -> 병합이 발생
  - 병합은 항상 위험이 따르고 도구는 모든 병합이 발생하는 경우를 해결할 수 없다.

- 정리
  - 서로 다른 목적으로 동일한 소스 파일을 변경하는 경우에 해당
  - 문제를 벗어나기 위해 서로 다른 액터를 뒷받침하는 코드를 서로 분리

### 7-2-3. 해결책

- 메서드를 각기 다른 클래스에 이동
- 데이터와 메서드를 분리

  - 메서드가 없는 간단한 데이터 구조를 EmloyeeData클래스 새성 -> 세 클래스가 공유
  - 각 클래스는 자신이 필요한 소스 코드만을 포함
  - 세 클래스는 서로의 존재를 몰라야 한다. -> 우연한 중복을 피함
  - 단점: 개발자가 세 가지 클래스를 인스턴스화하고 추적해야 한다

- 피사드 패턴(Facade) 을 적용
  - EmployeeFacade에 코드는 거의 없다.
  - 세 클래스의 객체를 생성하고 요청된 메서드를 가지는 객체 -> 위임하는 역할
  - 개발자는 가장 중요한 업무 규칙을 데이터와 가깝게 배치하는 방식을 선호
    - 가장 중요한 메서드는 Employee클래스의 유지
    - 덜 중요한 메서드들을 덜 중요한 나머지 메서드들에 대한 피사드로 사용
    - 모두 다수의 private 메서드를 포함
  - 여러 메서드가 하나의 가족, 메서드의 가족을 포함하는 각 클래스가 하나의 유효범위
  - 해당 유효범위 바깥에선는 이 가족에게 Private 멤버가 있는지 파악 못한다.

### 7-2-4. 결론

- 단일 책임 원칙은 메서드와 클래스 수준의 원칙
- 이보다 상위의 두 수준에서도 다른 형태로 다시 등장
- 컴포넌트 수준에서는 공통폐쇄 원칙
- 아키텍처 수준에서는 아키텍처 경계의 생성을 책임지는 변경의 축
