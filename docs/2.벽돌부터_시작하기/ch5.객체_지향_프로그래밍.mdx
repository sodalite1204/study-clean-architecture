---
sidebar_position: 3
---

# 5장 객체 지향 프로그래밍

- 좋은 아키텍처를 만드는 일은 객체 지향 Object-Oriented OO 설계 원칙을 이해하고 응용하는 데서 출발한다.
- 그렇다면 OO란 무엇일까? 이 질문에 대해 누군가는 “데이터와 함수의 조합" 이라고 답할 수 있다.
- OO의 본질을설명하기 위해 세 가지 주문에 기대는 부류도 있는데, 캡슐화 encapsulation, 상속 inheritance, 다형성 polymorphism이 바로 그 주문이다.

## 5-1. 캡슐화

- 데이터와 함수를 쉽고 효과적으로 캡슐화 하는 방법을 OO언어가 제공한다.
- 구분선 바깥에서 데이터는 은닉되고, 일부 함수만이 외부에 노출된다. 이 개념들이 OO언어에서는 각각 클래스의 private 멤버 데이터와 public 멤버 함수로 표현된다.
- 언어에 public, private, protected 키워드를 도입함으로써 불완전한 캡슐화를 사실상 어느정도 보완하기는 앴으나 OO가 강력한 캡슐화에 의존하지는 않는다. 실제로 많은 OO언어가 캡슐화를 거의 강제하지 않는다. (python, javascript, Ruby 등) OO 프로그래밍은 프로그래머가 충분히 올바르게 행동함으로써 캡슐화된 데이터를 우회해서 사용하지 않을 거라는 믿음을 기반으로 한다.

## 5-2. 상속

- OO언어가 더 나은 캡슐화를 제공하지는 못했지만 **상속만큼은 OO언어가 확실히 제공**했다.
- 상속이란 단순히 **어떤 변수와 함수를 하나의 유효 범위로 묶어서 재정의**하는 일에 불과하다. 이는 사실상 OO언어가 있기 훨씬 이전에도 C프로그래머는 언어의 도움없이 이러한 방식으로 구현할 수 있었다.
- OO 언어가 완전히 새로운 개념을 만들지는 못했지만, 데이터 구조에 가면을 씌우는 일을 상당히 편리한 방식으로 제공했다고 볼 수는 있다.

![상속 in javascript](https://user-images.githubusercontent.com/61774575/187015334-778253ce-991d-426d-90fe-c680440f6736.png)
_상속 in javascript / 출처 - https://overcome-the-limits.tistory.com/158_

## 5-3. 다형성

- 함수를 가리키는 포인터를 응용한 것이 다형성이다.
- OO언어는 다형성을 제공하지는 못했지만 다형성을 좀 더 안전하고 더욱 편리하게 사용할 수있게 해준다.

## 5-4. 다형성이 가진 힘

- 새로운 입출력 장치가 생긴다면 프로그램에는 어떤 변화가 생길까? 이 새로운 장비에서도 복사 프로그램이 동작하도록 만들려면 어떻게 수정해야 하는가? 아무런 변경도 필요치 않다! 복사 프로그램의 소스 코드는 입출력 드라이버의 소스코드에 의존하지 않기 때문이다.
- 당시 우리는 장치에 의존적인 수 많은 프로그램을 만들고 나서야, **이들 프로그램이 다른 장치에서도 동일하게 동작할 수 있도록 만드는 것이 우리가 진정 바랐던 일임을 깨달았다**.
- 플러그인 아키텍처는 이처럼 입출력 장치 독립성을 지원하기 위해 만들어졌고, 등장 이후 거의 모든 운영체제에서 구현되었다. OO의 등장으로 언제 어디서든 플러그인 아키텍처를 적용할 수 있게 되었다.

## 5-5. 의존성역전

- 다향성을 안전하고 편리하게 적용할 수 있는 메커니즘이 등장하기 전 소프트웨어는 어떤 모습이었을까.

![image](https://user-images.githubusercontent.com/61774575/187015477-c4cffa4f-83c8-44bd-a414-18528392be36.png)
_출처 - [https://velog.io/@gooreum_90/객체지향-프로그래밍](https://velog.io/@gooreum_90/%EA%B0%9D%EC%B2%B4%EC%A7%80%ED%96%A5-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D)_

- 전형적인 호출트리의 경우, main함수가 고수준 함수를 호출, 고수준 함수는 다시 중간 수준 함수를 호출, 중간 수준 함수는 다시 저수준 함수를 호출한다. 호출 트리에서 소스 코드 의존성의 방향은 반드시 제어흐름 flow of control을 따르게 된다.
- 즉, 제어흐름은 시스템의 행위에 아따 결정되며 소스코드 의존성은 제어흐름에 따라 결정된다.
- 하지만, 다형성이 끼어들면 무언가 특별한 일이 일어난다.

![image](https://user-images.githubusercontent.com/61774575/187015490-b0e6308d-d88f-4fb1-ad14-71fcdd1f532b.png)
_출처 - [https://velog.io/@gooreum_90/객체지향-프로그래밍](https://velog.io/@gooreum_90/%EA%B0%9D%EC%B2%B4%EC%A7%80%ED%96%A5-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D)_

- 그림에서 HL1 모듈은 ML1모듈의 F()함수를 호출한다. 소스코드에서는 HL1 모듈은 인터페이스를 통해 F() 함수를 호출한다. 이 인터페이스는 런타임에는 존재하지 않는다. HL1은 단순히 ML1모듈의 함수 F()를 호출할 뿐이다.
- 하지만 ML1과 I 인터페이스 사이의 소스코드 의존성(상속관계)이 제어흐름과는 반대인 점을 주목하자.
- OO언어가 다형성을 안전하고 편리하게 제공한다는 사실은 소스 코드 의존성을 어디에서든 역전시킬 수 있다는 뜻이기도 하다.
- 즉, 소스코드 의존성이 제어흐름의 방향과 일치되도록 제한하지 않는다. 이것이 바로 OO가 제공하는 힘이다.

![image](https://user-images.githubusercontent.com/61774575/187015514-44adc45d-8b9b-435a-803d-e6466d0a6156.png)
_출처 - [https://velog.io/@gooreum_90/객체지향-프로그래밍](https://velog.io/@gooreum_90/%EA%B0%9D%EC%B2%B4%EC%A7%80%ED%96%A5-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D)_

- 이를 활용하여 업무규칙이 db와 UI에 의존하는 대신에, 시스템의 소스코드 의존성을 반대로 배치하여 db와 UI가 업무 규칙에 의존하게 만들 수 있다. 결과적으로 업뮤규칙, UI, 데이터베이스는 세 가지로 분리된 컴포넌트 또는 배포 가능한 단위로 컴파일할 수 있다. 시스템의 모듈을 독립적으로 배포할 수 있게 되면, 서로 다른 다팀에서 각 모듈을 독립적으로 개발할 수 있다.
- 즉, OO란 다형성을 이용하여 전체 시스템의 모든 소스 코드 의존성에 대한 절대적인 제어 권한을 획득할 수 있는 능력이다.이를 통해 고수준의 정책을 포함하는 모듈은 저수준의 세부사항을 포함하는 모듈에 대해 독립성을 보장할 수 있다.
