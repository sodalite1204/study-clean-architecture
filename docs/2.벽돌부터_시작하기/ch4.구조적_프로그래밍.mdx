---
sidebar_position: 2
---

# 4장 구조적 프로그래밍

## 4-1. 증명

- 데이크스트라가 초기에 인식한 문제는 프로그래밍은 어렵고, 프로그래머는 프로그래밍을 잘하지 못한다는 사실이었다.
- 아주 작은 세부사항이라도 간과하면 프로그램이 동작하는 것처럼 보이더라도 결국엔 예상 외의 방식으로 실패하곤 했다.
- 그는 `증명 proof`라는 수학적인 원리를 적용해 이 문제를 해결하고자 했다.
- 이는 프로그래머는 **입증된 구조를 이용하고, 이들 구조를 코드와 결합시키며, 그래서 코드가 올바르다는 사실을 스스로 증명하게 되는 방식**이었다.
- 그는 이 연구를 진행하며 goto 문장이 모듈을 더 작은 단위로 분해하는 과정에 방해가 되는 경우가 있다는 사실을 발견. (• 모듈을 분해할 수 없다면, 합리적으로 증명할 때 필수적인 기법인 **분할 정복 접근법**을 사용할 수 없게 되기 때문이다.) 그러나 goto문도 if/then/else, do/while 같은 분기와 반복이라는 단순한 제어구조에서는 괜찮다.
- 즉, 모듈이 이러한 종류의 제어 구조만을 사용한다면 증명 가능한 단위로까지 모듈을 재귀적으로 세분화하는 것이 가능해보였다.

    <aside>
  💡 goto문은 아무런 조건 없이 어떤 위치로 점프하게 만드는 문장이다. goto문의 사용을 권장하지 않는 이유는 goto 문의 특성상 아무런 조건없이 갑자기 점프를 하기 때문에 프로그램을 읽는 사람들은 왜 점프를 하는지 알 수가 없어 프로그램을 아주 복잡하게 만든다. 대부분의 프로그래밍 언어는 조건문과 반복문을 지원해주는데, 이를 이용하면 GOTO가 없어도 프로그램을 작성하는 데에 문제가 거의 없다.

    </aside>

  ```jsx
  10 LET a = 10
  20 PRINT "타잔이 " + a + "원짜리 팬티를 입고, " + (a + 10) + "원짜리 칼을 차고 노래를 한다. 아아아~"
  30 LET a = a + 10
  40 IF a < 100 THEN GOTO 20
  50 END
  ```

- 뵘과 야코피니는 모든 프로그램을 순차 sequence, 분기 selection, 반복 iteration 이라는 세 가지 구조만으로 표현할 수 있다는 사실을 증명했다. 즉, 모듈을 증명 가능하게 하는바로 그 제어 구조가 모든 프로그램을 만들 수 있는 제어 구조의 최소 집합과 동일하다는 사실이었다.

## 4-2. 해로운 성명서

- 데이크스트라는 편지를 썼는데 그 제목은 ‘goto문의 해로움' 이었다. 당시 프로그래밍 세계는 불이 붙었다. 이 전쟁은 10년이상 지속되었다.
- 현재 컴퓨터 언어가 진화하면서 goto 문장은 계속 뒷편으로 밀려났고, 마침내 거의 사라졌다.
- 현재 우리 모두는 구조적 프로그래머이며, 여기에는 선택의 여지가 없다.

## 4-3. 기능적 분해

- 구조적 프로그래밍을 통해 모듈을 증명 가능한 더 작은 단위로 재귀적으로 분해할 수 있게 되었고, 이는 결국 **모듈을 기능적으로 분해할 수 있음**을 뜻했다.
- 즉, 거대한 문제 기술서를 받더라도 **문제를 고수준의 기능들로 분해**할 수 있다. 그리고 이들 각 기능은 **다시 저수준의 함수들로 분해**할 수 있고, 이러한 분해과정을 끝없이 반복할 수 있다.
- 이렇게 분해한 기능들은 구조적 프로그래밍의 제한된 제어구조를 이용하여 표현할 수 있다.
- 이 같은 기법을 사용한다면, 프로그래머는 대규모 시스템을 **모듈과 컴포넌트**로 나눌 수 있고, 더 나아가 모듈과 컴포넌트는 입증할 수 있는 **아주 작은 기능들로 세분화**할 수 있다.

## 4-4. 엄밀한 증명은 없었다.

- 하지만 끝내 증명은 이루어 지지 않았다.
- 오늘날 이처럼 엄밀한 증명이 고품질의 소프트웨어를 생산하기 위한 적절한 방법이라고 믿는 프로그래머는 이제 거의 없다.

## 4-5. 과학이 구출하다.

- 과학은 서술된 **내용이 사실임을 증명하는 방식이 아니라 서술이 틀렸음을 증명하는 방식**으로 동작한다.

## 4-6. 테스트

- 테이크스트라는 “테스트는 버그가 있음을 보여줄 뿐, 버그가 없음을 보여줄 수는 없다"고 말한 적이 있다.
- 사실 소프트웨어는 과학과 같다. 올바르지 않음을 증명하는데 실패함으로써 올바름을 보여주기 때문이다.

## 4-7. 결론

- 구조적 프로그래밍이 오늘날까지 가치있는 이유는 **프로그래밍에서 반증 가능한 단위를 만들어 낼 수 있는 바로 이 능력 때문**이다. 소프트웨어 아키텍트는 모듈, 컴포넌트, 서비스가 쉽게 반증 가능하도록 테스트하기 쉽도록 만들기 위해 분주히 노력해야 한다.
