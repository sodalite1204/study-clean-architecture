---
sidebar_position: 10
---

# 24장 부분적 경계

아키텍처 경계를 완벽하게 만들기 위해 필요한 요소

- 쌍방향의 다형적 인터페이스, Input과 Output을 위한 데이터 구조
- 두 영역을 독립적으로 컴파일하고 배포할 수 있는 컴포넌트로 격리한는 데 필요한 모든 의존성을 관리
- 하지만, 뛰어난 아키텍트라면 경계를 만드는 비용이 너무 크다고 판단하면서도, 나중에 필요할 수 있다고 판단하여
  오히려 경계에 필요한 공간을 확보하기 원할 수도 있지만, 부분적 경계를 구현해보면 좋다.

## 24-1. 마지막 단계를 건너뛰기

- 부분적 경계를 생성하는 방법
  - 독림적으로 컴파일하고 배포할 수 있는 컴포넌트를 만들기 위한 작업은 모두 수행한 후,
    단일 컴포넌트에 그대로 모아만 두는 것.
  - 쌍방향 인터페이스, 입출력 데이터 구조가 컴포넌트 안에 존재 -> 하지만, 단일 컴포넌트로 컴파일해서 배포
- 부분적 경계를 만들려면 완벽한 경계를 만들 때 만큼의 코드량과 사전 설계과 필요하다.
  - 하지만, 다수의 컴포넌트 관리, 추적을 위한 버전 번호 관리, 배포 관리 부담이 없다.

## 24-2. 일차원 경계

- 완벽한 형태의 아키텍처 경계는 양방향으로 격리된 상태를 유지하기 위해 **쌍방향 Boundary 인터페이스**를 사용 -> 초기 설정 및 유지 비용이 많이 든다.
- 추후 완벽한 형태의 경계로 확장할 수 있는 공간을 확보하기 위한 구조로 **전략 패턴**을 사용할 수 있다.

  ![전략패턴](https://blog.kakaocdn.net/dn/z1SA5/btrpjv9r2i5/kWVLPfTqBri3vB9l0dyybK/img.png)

  - ServiceBoundary 인터페이스는 클라이언트가 사용하며 ServiceImpl 클래스가 구현
  - Client를 ServiceImpl로부터 격리시키는 데 필요한 의존성 역전이 이미 적용되어 있다.
  - 쌍방향 인터페이스가 없고 개발자와 아키테그가 제대로 되어있지 않다면, 점선과 같은 비밀 통로를 막을 수 없다.

## 24-3. 퍼사드

- 단순한 경계 패턴
  ![](https://user-images.githubusercontent.com/20153890/124385826-68109880-dd12-11eb-9ab8-583f485ed5a8.png)
  - 의존성 역전까지도 희생
  - 경계는 Facade 클래스로만 정의. (Facade클래스에 모든 서비스 클래스를 메서도 형태로 정의하고,
    서비스 호출이 발생하면 해당 서비스 클래스로 호출을 전달. 클라이언트는 서비스 클래스에 직접 접근이 불가능)
  - 하지만 Client가 모든 서비스 클래스에 추이 종속성을 가진다.
  - 정적 언어였다면 서비스 클래스 소스 코드가 변경되면 Client도 재컴파일해야 한다.
    -> 비밀 통로를 쉽게 만들 수 있다는 사실을 파악하기 쉽다.

## 24-4. 결론

- 부분적으로 아키텍처 경계를 구현하는 방법은 각각 비용과 장점이 있으며, 상황에 따라 다르게 사용해야 한다.
- 아키텍처 경계가 언제, 어디서 존재햐야 할지, 경계를 완벽하게 혹은 부분적으로 구현할지 결정하는 일 또한 아키텍트의 역할이다.
