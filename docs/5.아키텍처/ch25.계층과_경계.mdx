---
sidebar_position: 11
---

# 25장 계층과 경계

단순한 시스템에서는 UI, 업무 규칙, 데이터베이스로만 구성되지만 대다수의 시스템에서는 무수의 컴포넌트가 존재한다.

## 25-1. 움퍼스 사냥 게임

- 움퍼스 사냥 게임? 단순한 명령어를 사용하는 텍스트 기반의 게임
- 가정: 텍스트 기반 UI는 유지하되, 게임 규칙과 UI를 분리하여 다양한 언어로 발매한다.
  - 게임 규칙 -> 언어 독립적인 API를 사용해서 UI 컴포넌트와 통신
  - UI -> API를 사람이 이해할 수 있는 언어로 변환
- 소스 코드 의존성을 적절히 관리 -> UI컴포넌트가 어떤 언어를 사용하더라도 게임 규칙을 재사용 가능해짐
- 게임의 상태를 영속적인 저장소에 유지하기
  - 어디에다가 저장하더라도 게임 규칙이 이러한 세부사항을 알지 않아야 한다.
  - 그렇기 때문에 API를 생성하여, 게임 규칙이 데이터 저장소에 대해 알지 못하게 해야 한다.

## 25-2. 클린 아키텍처?

- 움퍼스 사냥 게임의 예시로는 클린 아키텍처 접근법을 적용해서 유스케이스, 경계, 엔티티, 데이터 구조를 모두 만들기는 쉽지만,
  중요한 아키텍처 경계를 모두 발견했다고 할 수는 없다.
- UI에서 언어가 유일한 변경의 축은 아니다.
- 텍스트를 주고받는 메커니즘을 다양하게 만들고 싶을 수도 있다. (셸, 텍스트 메시지, 채팅 애플리케이션)
- 변경의 축에 의해 정의되는 아키텍처 경계가 잠재되어 있을 수 있다.
- 언어를 통신 메커니즘으로부터 격리되는 API를 생성해야 할 수도 있다.

### 25-2-1. 개션된 다이어그램

![개선된 다이어그램](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FnvkTk%2FbtqCckhpjwg%2Fm2FsDDAKLNsQozNYXOzA41%2Fimg.png)

- 점선 -> API를 정의하는 추상 컴포넌트

### 25-2-2. 단순화된 다이어그램

![단순](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FbS9xIz%2FbtqCaeJaN2N%2F4ngK7h8tdDnGWHBI3SJHx0%2Fimg.png)

- English, SMS, CloudData 와 같은 변형들은 추상 API가 정의하는 다형적 인터페이스를 통해 제공,
  실제로 서비스하는 구체 컴포넌트가 해당 인터페이스를 구현.
- 이런 변형들을 모두 제거하고 순전히 API 컴포넌트만 집중하여 다이어그램을 단순화할 수 있다.
- **모든 화살표가 위를 향하고 있다.(화살포는 데이터 흐름이 아닌, 소스 코드 의존성의 방향)** 즉, 정보가 흐르는 방향. (입력은 사용자로부터 전달받음)
  1. GameRules는 사용자 입력을 처리
  2. DataStorage로 데이터를 내려보냄
  3. GameRules는 Language로 출력을 되돌려 보냄
  4. Language는 API를 다시 적절한 언어로 번역한 후, 번역도니 언어를 TextDelivery를 통해서 사용자에게 전달
- 데이터 흐름들 두 개의 흐름으로 효과적으로 분리.
- 왼: 사용자와의 통신에 관여
- 오른: 데이터 영속성에 관여
- 상단의 GameRules에서 서로 만나고, GameRules는 두 흐름의 데이터 최종적인 처리기

## 25-3. 흐름 횡단하기

- 여러 사람이 플레이 한다면, 네트워크 컴포넌트를 추가해야 한다.
- 데이터 흐름을 Language/DataStorage/Network로 분리하되 흐름은 GameRules가 제어
- 즉, 시스템이 복잡해질수록 컴포넌트는 더 많은 흐름을 분리된다.

## 25-4. 흐름 분리하기

- 하지만, 모든 흐름이 상단의 단일 컴포넌트에서 만나지는 않는다.
  ![](https://blog.kakaocdn.net/dn/nRbNc/btqCd12eLfQ/KycR6BYik0ACuq2LnZGbTk/img.png)
- 플레이어가 처리해야하는 메커니즘이 복잡해 질수록 또 다른 정책 집합이 존재한다.
- 대규모 플레이어가 동시에 플레이한다면, 마이크로 서비스를 추가해서 아키텍처를 경계할 수 있다.

## 25-5. 결론

- 아키텍처의 경계는 어디에나 존재한다.
- 아키텍처 경계가 언제 필요한지를 신중하게 파악해야 한다.
- 경계를 제대로 구현하려면 비용이 많이 든다.
- 경계가 무시된다면 나중에 추가하는 비용도 크게 발생할 수 있다.
- 추상화가 필요하다고 미리 예측해서는 안된다. (You Aren't Going to Need It)
- 프로젝트 초반에 구현할 경계를 쉽게 결정할 수 없기 때문에 신중함을 기울어야 한다.
