---
sidebar_position: 2
---

# 16장 독립성

좋은 아키텍처가 지원해야 하는 것

- 시스템의 유스케이스
- 시스템의 운영
- 시스템의 개발
- 시스템의 배포

## 16-1. 유스케이스

_**시스템의 아키텍처는 시스템의 의도를 지원해야 한다**_

- 아키텍트의 최우선 관시사는 유스케이스이며, 아키텍처는 반드시 유스케이스를 지원해야 한다.
  예를들어, 장바구니 애플리케이션이면 장바구니 관련 유스케이스를 지원해야 한다.
- 하지만, 아키텍처는 시스템의 행위에 그다지 큰 영향을 주지 않는다.
  - 행위와 관련하여 아키텍처가 열어 둘 수 있는 선택사항이 거의 없다.
  - 영향력이 전부는 아니지만, 행위를 지원하기 위해서 중요 사항은 행위를 명확히 하여, 시스템이 지닌 의도를 아키텍처 수준에서 알아볼 수 있게 만들어야한다.
- 애플리케이션이 좋은 아키텍처를 갖춘다면, 해당 시스템의 유스케이스는 시스템
  구조 자체에서 한눈에 드러날 것이다.
  - 시스템의 최상위 수준에서 일급 요소(클래스, 함수, 모듈 등)를 알아볼 수 있다.

## 16-2. 운영

_**더 실질적이며 덜 피상적인 역할을 맡는다**_

- 시스템이 초당 100,000명의 고객을 처리해야 한다.
  - 아키텍처 -> 요구와 관련된 유스케이스에 걸맞은 처리량과 응답시간을 보장해야 한다.
- 시스템에서 수 밀리초 안에 3차원의 빅테이터 테이블을 질의해야 한다.
  - 이러한 운영 작업을 허용할 수 있는 형태로 아키텍처를 구조화.
- 뛰어난 아키텍트의 선택사항
  - 모노리틱 구조(시스템이 단일체 작성) -> 다중 프로세스, 다중 스레드, 또는 마이크로서비스 형태가 필요해질 때 개선하기 어려움.
  - 아키텍처에서 각 컴포넌트를 적절히 격리하여 유지하고 컴포넌트 간 통식 방식을 특정 형태로 제한하지 않는다면,
    시간이 지나 운영에 필요한 요구사항이 바뀌더라도 스레드, 프로세스, 서비스로 구성된 기술 스펙트럼 사이를 전환하는 일이 훨씬 쉬워질 것이다.

## 16-3. 개발

_**개발환경을 지원하는 데 있어 핵심적인 영학을 수행한다**_

- 콘웨이의 법칙이 작용하는 지점
- 콘웨이 법칙: 시스템을 설계하는 조직이라면 어디든지 그 조직의 의사소통 구조와 동일한 구조의 설계를 만들어 낼 것이다.
- 각 팀이 독립적으로 행동하기 편한 아키텍처를 반드시 확보하여 개발 -> 서로 방해하지 않도록
- 독립적으로 개발 가능한 컴포넌트 단위로 시스템을 분할할 수 있어야 한다. -> 컴포넌트를 독립적으로 작업할 수 있는 팀에 할당 가능하다.

## 16-4. 배포단위이다

_**배포 용이성을 결정하는 데 중요한 역할을 한다**_

- 목표: 즉각적인 배포
- 좋은 아키텍처는
  - 필요한 디렉터리나 파일을 수작업으로 생성하게 내버려 두지 않는다.
  - 시스템이 빌드된 후 즉각 배포할 수 있도록 지원해야 한다.
- 그래서, 시스템을 컴포넌트 단위로 적절하게 분할하고 격리
- 마스터 컴포넌트는 시스템 전체를 하나로 묶고, 각 컴포넌트를 올바르게 구동하고 통합하고 관리해야 한다.

## 16-5. 선택사항 열어놓기

_**컴포넌트 구조와 관련된 이 관심사들 사이에서 귷녕르 맞추고, 각 관심사 모두를 만족시킨다.**_

- 대부분의 경우 모든 유스케이스를 알 수 없으며, 운영하는 데 따르는 제약사항, 팀 구조, 배포 요구사항도 알지 못한다.
  -> 균형잡기가 매우 힘들다.
- 이런 목표는 계속 변화하지만, 없어지지 않는 것들도 있다.
- 그래서, 선택사항을 열어 둠으로써, 향후 시스템에 변경이 필요할 때 어떤 방향으로도 쉽게 변경할 수 있게 해야한다.

## 16-6. 계층 결합 분리

_**필요한 모든 유스케이스를 지원할 수 있는 시스템 구조를 원하지만, 유스케이스 전부를 알지는 못한다.(유스케이스 측면)**_

- 하지만, 시스템이 어떤 시스템인지의 기본적인 의도는 알고 있다.
- 따라서, 단일 책임 원칙과, 공통 폐쇄 원칙을 적용하여,
  그 의도의 맥락에 따라서 다른 이유로 변경되는 것들은 분리하고, 동일한 이유로 변경되는 것들을 묶는다.
- 사용자 인터페이스가 변경되는 이유는 업무 규칙과는 연관이 없다.
- 유스케이스에서 UI 부분과 업무 규칙 부분을 서로 분리하고자 하면, 두 요소를 서로 독립적으로 변경할 수 있으며,
  유스케이스는 가시적이고 분명하게 유지할 수있다.
- 업무 규칙은 그 자체가 애플리케이션과 밀접한 관련이 있거나, 더 범용적일 수 있다.
  - 예) 입력 필드 유효성 검사 -> 애플리케이션 자체와 밀접하게 관련된 업무 규칙. 그래서 서로 분리하고, 독립적으로 변경할 수 있도록 해야한다.
- 데이터베이스, 쿼리 언어, 스키마 -> 기술적인 세부사항. 업무 규칙이나 UI와는 관련성이 없다.
  - 시스템의 나머지 부분으로 분리하여 독립적으로 변경할 수 있도록 해야 한다.
- 시스템을 서로 결합되지 않은 수평적인 계층으로 분리하는 계층
  - UI, 애플리케이션에 특화된 업무 규칙, 애플리케이션과는 독립적인 업무 규칙, 데이터베이스 등.

## 16-7. 유스케이스 결합 분리

_**서로 다른 이유로 변경되는 것이 유스케이스 그 자체**_

- 예를 들어, 주문 입력 시스템에서 주문을 추가하는 유스케이스는 주문을 삭제하는 유스케이스와는 틀림없이 다른 속도로, 다른 이유로 변경된다.
- 유스케이스는 시스템을 변경하는 가장 자연스런 방법
- 시스템의 수평적인 계층을 가로지르도록 자른,수직으로 좁다란 조각이기도 하다.
- 각 유스케이스는 UI의 일부, 애플리케이션 특화 업무 규칙의 일부, 애플리케이션 독립적 업무 규칙의 일부, 그리고 데이터베이스 기능의 일부를 사용.
- 시스템을 수평적 계층으로 분할하면서 동시에 해당 계층을 가로지르는 얇은 수직적인 유스케이스로 시스템을 분할가능 ->
  시스템의 맨 아래 계층까지 수직으로 내려가며 유스케이스들이 각 계층에서 서로 겹치지 않게 해야한다.
- 시스템에서 서로 다른 이유로 변경되는 요소들의 결합을 분리하면 기존 요소에 지장을 주지 않고도 새로운 유스케이스를 계속해서 추가할 수 있게 된다.
- 유스케이스를 뒷받침하는 UI와 데이터 베이스를 서로 묶어서 각 유스케이스가 UI와 데이터베이스의 서로 다른 관점을 사용하게 되면,
  새로운 유스케이스르 추가하더라도 기존 유스케이스에 영향을 주는 일은 거의 없다.

## 16-8. 결합 분리 모드

_**유즈케이스에서 서로 다른 관점이 분리되었다면,
높은 처리량을 보장해야 하는 유스케이스와 낮은 처리량으로도 충분한 유스케이스는 이미 분리되어 있을 가능성이 높다.**_

- UI와 데이터베이스가 업무 규칙과 분리되어 있다면, UI와 데이터베이스는 업무 규칙과는 다른 서버에서 실행도리 수 있다.
- 높은 대역폭을 요구한는 유스케이스는 여러 서버로 복제하여 실행할 수 있다.
  => 유스케이스를 위해 수행하는 결합 분리는 운영에 도움이 된다.
- 하지만, 운영 측면에서 이점을 살리기 위해서 결합 분리시 적절한 모드를 선택해야 한다.
  - 분리된 컴포넌트를 서로 다른 서버에서 실행해야 하는 상황
    - 컴포넌트가 동일한 주소 공간에 함께 있으면 안된다.
    - 분리된 컴포넌트는 독립된 서비스 -> 네트워크를 통해 서로 통신
- 분리된 컴포넌트를 서비스 또는 마이크로 서비스라고 명명 (서비스에 기반한 아키텍처-> 서비스 지향 아키텍처)

- 컴포넌트를 서비스 수준까지 분리해야 한다.
- 좋은 아키텍처는 선택권을 열어 두며, 결합 분리 모드는 이 선택지 중의 하나이다.

## 16-9. 개발 독립성

_**계층과 유스케이스의 결합이 분리되는 한 시스템의 아키텍처는 그 팀 구조를 뒷받침해준다.**_

- 예를 들어, 업무 규칙이 UI를 알지 못하면 UI에 중점을 둔 팀은 업무 규칙에 중점을 둔 팀에 영향을 줄 수 없다.

## 16-10. 배포 독립성

_**유스케이스와 계층의 결합이 분리되면 배포 측면에서도 고도의 유연성이 생긴다.**_

- 결합을 제대로 분리했다면 운영 중인 시스템에서도 계층과 유스케이스를 교체할 수 있다.
- 새로운 유스케이스를 추가하는 일은 스스템의 나머지는 그대로 둔 채 새로운 파일이나 서비스 몇 개를 추가하는 정도로 단순한 일이 된다.

## 16-11. 중복

_**중복은 나쁜 것이 아니지만, 중복을 줄이거나 제거해야 한다.**_

- 진짜 중복
  - 인스턴스가 변경되면, 동일한 변경을 그 인스턴스의 모든 복사본에 반드시 적용해야 한다.
- 거짓된 중복, 우발적인 중복

  - 중복인 두 코드 영역이 각자의 경로로 발전한다면, 서로 다른 속도와 다른 이유로 변경된다면 이 코드는 중복이 아니다.

- 거짓된 중복일 경우는 나중에 코드를 다시 분리하느라 더 큰 수고가 발생한다.
- 진짜 중복인지 확인하야 한다.
- 계층을 수평으로 분리하는 경우 (우발적 중복의 예)
  - 특정 데이터베이스 레코드의 데이터 구조가 특정 화면의 데이터 구조와 비슷한 점을 발견
  - 데이터 베이스 레코드와 동일한 형태의 뷰 모델을 만들어서 각 항복을 복사하는 게 아니라, 데이터베이스 레코드르 있는 그대로 UI까지 전달
    => 뷰 모델을 별도로 만드는 일은 많은 노력이 들지 않고, 계층 간 결합을 적절하게 분리하여 유지하는 데도 도움이 된다.

## 16-12. 결합 분리 모드(다시)

_**계층과 유스케이스의 결합을 분리하는 방법은 다양한다.**_

- 소스 코드 수준, 바이너리 코드(배포),실행 단위(서비스)수준에서 분리 가능하다.

### 16-12-1. 소스 수준 분리 모드

소스 코드 모듈 사의의 의존성을 제가할 수 있다. 이를 통해 하나의 모듈이 변하더라도 다른 모듈을 변경하거나 재컴파일하지 않도록 만들 수 있다. (루비Gem)
모든 컴포넌트가 같은 주소 공간에서 실행되고, 서로 통신할 때는 간단한 함수 호출을 사용. 컴퓨터 메모리에는 하나의 실행 파일만이 로드(모노리틱 구조)

### 16-12-2. 배포 수준 분리 모드

jar파일, DLL, 공유 라이브러리와 같이 배포 간으한 단위들 사이의 의존성을 제거할 수 있다. 이를 통해 한 모듈의 소스 코드가 변하더라도 다른 모듈을 재빌드하거나 재배포하지 않도록 만들 수 있따.
많은 컴포넌트가 같은 주소 공간에 상주하며, 단순한 함수 호출을 통해 통신할 수 있다.
어떤 컴포넌트는 동일한 프로세서의 다른 프로세스에 상주하고, 프로세스 간 통신, 소켓 또는 공유 메모리를 통해 통신할 수 있다.
**결합이 분리된 컴포넌트가 jar 파일, Gem 파일, DLL과 같이 독립적으로 배포할 수 있는 단위로 분할되어 있다**

### 16-12-3. 서비스 수준 분리 모드

의존하는 수준을 데이터 구조 단위까지 낮출 수 있고, 네트워크 패킷을 통해서만 통신하도록 만들 수 있다.
이를 통해 모든 실행 가능한 단위는 소스와 바이너리 변경에 대해 서로 완전히 독립적이게 된다. (서비스 또는 마이크로서비스)

### 16-12-4. 정리

- 프로젝트 초기 단계는 최선을 알기 어렵다. 프로젝트의 볼륨에 따라 최적 모드가 달라진다.
- 좋은 아키텍처는
  - 시스템이 모노리틱 구조로 태어나서 단일 파일로 배포되더라도 이후에서는 독립적으로 배포 가능한 단위들의 집합으로 성장하고, 또 독립적인 서비스나 마이크로서비스 수준까지 성장할 수 있도록 만들어져야 한다.
  - 상황이 바뀌었을 때 이 진행 방향을 거꾸로 돌려 원래 형태인 모노리틱 구조로 되돌릴 수 있어야 한다.
  - 변경으로부터 소스 코드 대부분을 보호한다.
  - 결합 분리 모드를 선택사항으로 남겨두어서 배포 규모에 따라 가장 적합한 모드를 선택해 사용할 수 있게 만들어 준다.

## 16-13. 결론

_**시스템의 결합 분리 모드는 시간이 지나면서 바뀌기 쉬우며, 뛰어난 아키텍트라면 이러한 변경을 예측하여 무리 없이 반영할 수 있도록 만들어야 한다.**_
