---
sidebar_position: 8
---

# 22장 클린 아키텍처

여러 아키텍처는 모두 세부적인 면에서 차이가 있어도 내용은 비슷하다.
목표는 모두 **관심사의 분리**.
소프트웨어을 계층으로 분리함으로써 관심사를 분리할 수 있었다.
각 아키텍처는 최소한 업무 규칙을 위한 계층하나와, 사용자와 시스템 인터페이스를 위한 또 다른 계층 하나를 반드시 포함한다.
그리고, 다음과 같은 특징을 지나도록 만든다.

1. 프레임워크 독립성

- 프레임워크의 존재 여부에 의존하지 않고, 프레임워크의 제약으로 시스템을 강제하지 않는다.

2. 테서트 용이성

- 업무 규칙은 UI,데이터베이스, 웹 서버, 다른 외부 요소가 없어도 테스트할 수 있다.

3. UI독립성

- 시스템의 g나머지 부분을 변경하지 않고도 UI를 쉡게 변경할 수 있다.

4. 데이터베이스독립성

- 오라클, MS SQL를 몽고DB,빅테이블, 카우치등으로 교체할 수 있다.
- 업무 규칙은 데이터베이스에 결합되지 않는다.

5. 모든 외부 에이전시에 대한 동립성

- 업무 규칙은 외부 세계와의 인터페이스에 대해 전혀 알지 못한다.
  ![image](https://user-images.githubusercontent.com/91005609/195999470-10d749d3-0586-4ccc-a405-c3d48eccabb4.png)
  [그림 22-1]

## 22-1. 의존성 규칙

- 그림 22-1 의 각 동심원은 소프트웨어에서 서로 다른 영역을 표현
- 밖 -> 안 => 저수준 -> 고수준 소프트웨어
- 바같 -> 메카니즘, 안 -> 정책
- 이런 아키텍처가 동작하도록 하는 가장 중요한 규칙은 **의존성 규칙**이다.
- 소스코드의 의ㅡ존성은 반드시 안쪽으로 고수준의 정책을 향해야 한다.
- 내부에 속한 요소는 외부의 원에 속한 어떤 것도 알지 못한다. 이름을 언급해서도 안된다.
- 외부의 원에서 선언된 데이터 형식도 내부의 원에서 절대로 사용해서는 안된다.
- _**외부 원에 위치한 어떤 것도 내부의 원에 영향을 주지 않아야 한다.**_

### 22-1-1. 엔티티

- _**엔티티는 전사적인 핵심 업무 규칙을 캡슐화한다.**_
- 메서들르 가지는 객체이거나 일련의 데이터 구조와 함수의 집합일수도 있다.
- 기업의 다양한 애플리케이션에서 엔티티를 재사용할 수만 있다면 형태는 중요하지 않다.
- 단순한 단일 애플리케이션을 작성하고 있을 때의 엔티티
  - 해당 애플리케이션의 일부 객체가 된다. -> 가장 일반적, 고수준의 규칙을 캡슐화
  - 외부의 무언가가 변경되더라도 엔티티가 변경된 가능성은 낮다.
  - 운영 관점에서도 특정 애플리케이션이 변경이 필요해도 엔티티 계층에는 영향을 주면 안 된다.

### 22-1-2. 유스케이스

- _**애플리케이션에 특화된 업무 규칙을 포함하며, 시스템의 모든
  유스케이스를 캡슐화하고 구현한다.**_
- 유스케이스는 엔티티로 들어오고 나가는 데이터 흐름을 조정하며,
  엔티티가 자신의 핵심 업무 규칙을 사용해서 유스케이스의 목적을 달성하도록 이끈다.
- 유스케이스 계층에서 발생한 변경이 엔티티에 영향을 줘서는 안 된다.
  (데이터베이스, UI, 프레임워크드으이 관심사로부터 격리되어 있다.)
- 하지만, 운영 관점에서 애플리케이션이 변경된다면, 유스케이스가 영향을 받아 소프트웨어 및 코드 일부에 영향을 끼친다.

### 22-1-3. 인터페이스 어댑터

- _**일련의 어댑터들로 구성되며, 어댑터는 데이터를 유스케이스와 엔티티에게 가장 편리한 형식에서
  데이터베이스나 웹 같은 외부의에이전시에게 가장 편리한 형식이으로 변환한다.**_
- 데이터를 엔티티와 유스케이스에게 가장 편리한 형식에서 임의의 프레임워크가 이용하기에 가장 편리한 형식으로 변환한다.
- 이 원에 속한 어떤 코드도 데이터베이스에 알아서는 안 된다.
- 데이터를 외부 서비스나 같은 외부적인 형식에서 유스케이스나 엔티티에 사용되는 내부적인 형식으로 변환하는 또 다른 어탭터가 필요하다.

### 22-1-4. 프레임워크와 드라이버

- 모든 세부사항이 위치하는 곳.
- 안쪽 원과 통신하기 위한 접한 코드 외에 작성해야 하는 코드는 많지 않다.
- 웹, 데이터 베이스 등의 세부사항을 모두 외부에 위치시켜 피해를 최소화한다.

### 22-1-5. 원은 네 개여야만 하나?

- 원의 개수는 상관없지만, 어떤 경우에도 의존성 규칙은 적용된다.
- 소스 코드 의존성은 항상 안쪽을 향한다.
- 안쪽으로 이동할수록 추상화와 정책의 수준은 높아진다.
- 바깥 원은 저수준의 구체적인 세부사항을 구성된다.
- 안쪽으로 이동할수록 소프트웨어는 추상화되고 더 높은 수준의 정책들을 캡슐화한다.
- 가장 안쪽 원 -> 가장 범용적, 높은 수준

### 22-1-6. 경계 횡단하기

- 제어흐름과 의존성의 방향이 반대여야 하는 경우, 의존성 역전 원칙을 사용하여 해결
- 예) 자바
  - 인터페이스와 상속 관계를 적절하게 배치함으로써,
    제어흐름이 경계를 가로지르는 지점에서 소스 코드 의존성을 제어흐름과 반대가 되게 만든다.
- 아키텍처 경게를 횡단할 때, 동적 다형성을 이용하여 소스 코드 의존성을 제어흐름과 반대로 만들 수 있으며, 의존성 규칙을 준수할 수 있다.

### 22-1-7. 경계를 횡단하는 데이터는 어떤 모습인가

- 격리되어 있는 간단한 데이터 구조가 경계를 가로질러 전달된다.
- 경계를 가로질러 데이터를 전달할 때, 데이터는 항상 내부의 원에서 사용하기에 가장 편리한 형태를 가져야 한다.

## 22-2. 결론
- 소프트웨어를 계층으로 분리하고 의존성 규칙을 준수한다면 본질적으로 테스트하기 쉬운 시스템을 만들게 되며 그에 따른 이점을 누릴 수 있다.
- 그래야, 시스템의 외부 요소를 언제든지 교체할 수 있다.
