---
sidebar_position: 1
---

# 15장 아키텍처란?

아키텍처의 주된 목적은 시스템의 생명주기를 지원하는 것.
시스템의 수명과 관련된 비용을 최소화하고, 프로그래머의 생산성을 최대화 하는 것.

좋은 아키 텍처란?

- 시스템을 쉽게 이해
- 쉽게 개발
- 쉽게 유지보수
- 쉽게 배표가 가능

## 15-1. 개발

- 팀 규모에 따른 아키텍처
  - **소규모**: 잘 정의된 아키텍처와 컴포넌트가 없어도 효율적으로 개발이 가능.
    오히려 초기에는 아키텍처 제약이 방해될 수도 있다.
  - **대규모**: 잘 정의된 아키텍처와 컴포넌트가 없으면 개발이 진척되지 않다.
    팀별 단일 컴포넌트 아키텍처가 배포, 운영, 유지보수에 최적화될 수 없다.

## 15-2. 배포

- 배포 비용이 높을수록 시스템의 유용성이 떨어진다.
- 시스템을 단 한 번에 쉽게 배포할 수 있도록 만드는 데 목표를 두어야 하며,
  **개발 초기 단계에 개발 배포 전력을 세워야 한다.**
- 그렇지 않으면, 서비스들을 연결하기 위한 설정 및 작동 순서를 결정하면서 오작동이
  발생할 수도 있다. => 초기에 고려함으로서, 작은 단위의 서비스 컴포넌트와 프로세스 수준의
  컴포넌트를 하이브리드 형태로 융합하여, 상호 연결을 관리할 수 있다.

## 15-3. 운영

- 운영에서의 어려움은 단순히 하드웨어를 더 투입해서 해결할 수 있다.
  - 스토리지와 서버를 추가하여 제대로 동작하게 만들 수 있을 때가 많기 때문.
  - 하드웨어는 값싸고 인력은 비싸다 -> 운영을 방해하는 아키텍처가 개발, 배포, 유지보수 쪽으로 더 기울기 때문
- 시스템을 운영하는 데 필요한 요구를 알려준다. 즉, 시스템 아키텍처가 개발자에게 시스템의 운영 방식을 잘 드러내 준다.
- 시스템 아키텍처는 유스케이스, 기능, 시스템의 필수 행위를 일급 엔티티로 격상시키고, 이들 요소가 개발자에게 주요 목표로 인식되도록 해야 한다.
  - 시스템 이해도하기가 쉬워지며,
  - 개발과 유지보수에 도움이 된다.

## 15-4. 유지보수

- 모든 측면에서 **비용이 가장 많이** 든다.
- 가장 큰 비용은 탐사와 이로 인한 위험부담
  - 탐사: 기존 소프트웨어에 새로운 기능을 추가하거나, 결함을 수정할 때, 최선의 수정사항 부분과, 최적의 전략을 결정하는 데 드는 비용.
    변경사항을 반영할 때 결함 발생가능성은 항상 존재, 그래서 위험부담 비용이 추가될 수도 있다.
- 신중하게 아키텍처를 만들면 유지보수 비용을 줄일 수 있다.

## 15-5. 선택사항 열어 두기

- 소프트웨어의 가치
  - 행위적 가치
  - 구조적 가치(중요) -> 소프트웨어를 부드럽게 만들기 때문
- 소프트웨어를 만든 이유
  - 기계의 행위를 빠르고 쉽게 변경하는 방법이 필요했기 때문
  - 그래서, 이런 유연성이 시스템의 형태, 컴포넌트의 배치 및 상호연결 방식의 의존도가 크다.
- 소프트웨어 시스템의 구성요소
  - 정책
    - 모든 업무 규칙과 업무 절차를 구체화 (시스템의 진정한 가치)
  - 세부사항
    - 사람, 외부 시스템, 프로그래머가 정책과 소통할 때 필요한 요소
    - 정책이 가진 행위에는 영향을 미치치 않음
    - 입출력 장치, 데이터베이스, 웹 시스템, 서버, 프레임워크, 통신 프로토콜
- 아키텍트의 목표는 시스템에서 정책을 가장 핵심적인 요소로 식별하고,
  동시에 세부사항은 정책에 무관하게 만들 수 있는 형태의 시스템을 구축하는 것
  - 그래서, 세부사항을 결정하는 일은 미루거나 연기할 수 있게 된다. (세부사항에 몰두하지 않은 채 고수준의 정책을 만든다면)
  - 연기한다면, 더 많은 정보를 얻을 수 있고, 제대로 결정을 내릴 수 있다.
- **_좋은 아키텍트는 결정되지 않은 사항의 수를 최대화_**₩

## 15-6. 장치 독립성

- 어떤 장치를 사용할지 전혀 모르고, 고려하지 않아도 프로그램을 작성할 수 있게 하는 것.
- 오늘날의 운영체제는 입출력 장치를 소프트웨어 함수로 추상화했고, 해당 함수는 천공카드와 같은 단위 레코드를 처리.
- 프로그램은 운영체제의 서비스를 호출하고, 해당 서비스가 추상화된 단위 레코드 장치를 처리.
- 오퍼레이터가 해당 추상 서비스를 카드 판독기, 자기 테이프 등 연결해야 하는지를 운영체제에게 알려줌.
- 이로인해 동일한 프로그램을 아무런 변경 없이도 카드에서 읽고 쓰거나, 테이프에서 읽고 쓸 수 있게 되었다 (개방 폐쇄 원칙이 탄생)

## 15-7. 결론

- 좋은 아키텍트는 세부사항을 정책으로부터 신중하게 가려내고, 정책이 세부사항과 결합되지 않도록 엄격하게 분리.
- 이를 통해 정책은 세부사항에 관한 어떤한 지식도 갖지 못하게 되며, 어떤 경우에도 세부사항에 의존하지 않게 된다.
- 세부사항에 대한 결정을 가능한 한 오랫동안 미룰 수 있는 방향으로 정책을 설계.
