---
sidebar_position: 1
---

# 12장 컴포넌트
- 컴포넌트는 배포단위이다.
- 컴포넌트는 시스템의 구성요소로 배포할 수 있는 가장 단위이다. (예 - ruby의 gem file)
- 잘 설계된 컴포넌트라면, 반드시 독립적으로 배포 가능한 (개발 가능한) 능력을 갖추어야 한다.

## 12-1. 컴포넌트의 간략한 역사

- 프로그래밍 초창기에는 프로그램을 로드할 메모리의 위치를 정하는 일이 프로그래머가 가장 먼저 결정해야 하는 사항 중 하나였다.
- 라이브러리를 사용한다면, 프로그래머는 라이브러리 함수의 소스코드를 애플리케이션 코드에 직접 포함시켜 단일 프로그램으로 컴파일 했다. 그 당시 라이브러리는 바이너리가 아니라 소스 코드 형태로 유지되었다.
- 이시대에는 장치는 느리고 메모리는 너무 비싸 자원이 한정적이었기에 소스 코드 전체를 메모리에 상주시킬 수 없었고 여러 차례 읽어야 했으며 라이브러리 크기에 따라 컴파일 소요시간은 비례적으로 늘어났다.
- 컴파일 시간을 단축시키기 위해 아래 그림과 같이 함수 라이브러리의 소스코드를 애플리케이션 코드로 부터 분리했다. 애플리케이션이 점점 커짐에 따라 두 개의 주소 세그먼트로 분리해 함수 라이브러리 공간을 사이에 두고 오가며 동작하게 배치하게 되었다.

![[https://wedonttalknemore.tistory.com/19]](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2Fee10iG%2Fbtq0Y4U6M9o%2FDJp1sLCCmk5VP94XoeS2M1%2Fimg.png)
[https://wedonttalknemore.tistory.com/19](https://wedonttalknemore.tistory.com/19)

- 그러나 이 역시 프로그램과 라이브러리가 사용하는 메모리가 늘어날수록 이와 같은 단편화는 계속될 수 밖에 없었다.

## 12-2. 재배치성

- “재배치가 가능한 바이너리(relocatable binary)”가 해결책이었다.
- 지능적인 로더를 사용해서 메모리에 재배치를 할 수 있는 형태의 바이너리를 생성하도록 컴파일러를 수정하자는 것이었다.
- 로더는 재배치 코드가 자리할 위치를 전달받고, 재배치 코드에는 로드한 데이터에서 어느 부분을 수정해야 정해진 주소에 로드할 수 있는지를 알려주는 플래그(바이너리에서 참조하는 메모리의 시작주소)가 삽입되었다.
- 이로 인해 프로그래머가 할 수 있는 것
    - 함수 라이브러리를 로드할 위치와 애플리케이션을 로드할 위치를 로더에게 지시할 수 있어짐.
    - 단순히 하나씩 차례로 메모리로 로드하며 재배치 작업을 처리함으로써 프로그래머는 오직 필요한 함수만을 로드할 수 있어짐.
    - 컴파일러는 재배치 가능한 바이너리 안의 함수 이름을 ‘메타데이터 형태’로 생성하도록 수정됨으로 외부 참조, 외부정의로 생성됨.
    - 이렇게 ‘링킹 로더 linking loader’가 탄생함

## 12-3. 링커

- 링킹 로더의 등장으로 프로그래머는 프로그램을 개별적으로 컴파일하고 로드할 수 있는 단위로 분할할 수 있게 되었다.
- 그러나 1960년대 - 1970년대,프로그램은 더 커지게 되면서 결국 링킹 로더가 너무 느려 참을 수 없는 지경까지 왔다.
- 그래서 링킹로더는 ‘로드’와 ‘링크’ 두 단계로 분리되었고, ‘링커’linker 라는 별도의 어플리케이션으로 링크 과정을 처리하도록 했다.
- 링커는 링크가 완료된 재배치 코드를 만들어 주었고, 그 덕에 로더의 로딩과정이 아주 빨라졌다.
- 그러나 시간이 지나 1980년대가 됨에 따라 프로그램 코드는 수십만 라인을 넘어서게 되었고, 결국 전체 소요 시간은 또다시 늘어났다. 로드 시간은 빨랐지만 ‘컴파일-링크’시간이 병목이었다.
- 컴퓨터 속도, 메모리, 집적도가 매 18개월마다 두 배로 증가한다는 주장이 등장했고, 디스크는 작아지며 놀랄만큼 빨라졌다.
- 1990년대 후반이 되자, 프로그램이 성장하는 속도보다 링크 시간이 줄어드는 속도가 더 빨라지기 시작했다. 많은 경우 링크 시간은 초단위 수준이 되었다.
- 이렇게 액티브 x와 공유라이브러리 시대가 열렸다. 컴포넌트 플러그인 아키텍처가 탄생했다.
- 오늘날에는 공유라이브러리를 기존 애플리케이션에 플러그인 형태로 배포하는 것이 일상적인 일이 되었다.

## 12-4. 결론

- 런타임에 플러그인 형태로 결합할 수 있는 동적링크파일 (Dynamic Link Library)이 이 책에서 말하는 소프트웨어 컴포넌트에 해당한다.
